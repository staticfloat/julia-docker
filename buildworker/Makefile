include ../common.mk

buildall:

# Build mapping from buildbot name to worker base image
BOTNAMES=

# Add x86_64 botnames
BOTNAMES += linux-x86_64-nanosoldier1_1 linux-x86_64-nanosoldier2_1 linux-x86_64-nanosoldier2_2
# Add i686 botnames
BOTNAMES += linux-i686-nanosoldier1_1 linux-i686-nanosoldier3_1 linux-i686-nanosoldier3_2
# Add ppc64le botnames
BOTNAMES += linux-ppc64le-osu_1 linux-ppc64le-osu_2 linux-ppc64le-osu_3 linux-ppc64le-osu_4
# Add aarch64 botnames
BOTNAMES += linux-aarch64-packet_1 linux-aarch64-packet_2 linux-aarch64-packet_3 linux-aarch64-packet_4
BOTNAMES += linux-aarch64-packet_5 linux-aarch64-packet_6 linux-aarch64-packet_7 linux-aarch64-packet_8
# Add armv7l botnames
BOTNAMES += linux-armv7l-firefly_1 linux-armv7l-firefly_2 linux-armv7l-firefly_3 linux-armv7l-rock64_1

# Extract the arch from a botname
define bot_arch
$(strip $(basename $(subst -,.,$(patsubst linux-%,%,$(1)))))
endef

# Build mapping function from botname to worker base image
define bot_image
$(strip $(call arch_filt,$(call bot_arch,$(1)),$(HFS)))
endef

# Build "buildall" target that builds the docker-compose directories for each bot
$(foreach b,$(BOTNAMES),$(eval $(call add_dep,buildall,build-$(b))))

# Build "deployall" target that brings up all images that are compatible with our arch
BUILD_BOTNAMES=$(call arch_filt,$(BUILD_ARCHS),$(BOTNAMES))
$(foreach b,$(BUILD_BOTNAMES),$(eval $(call add_dep,deployall,deploy-$(b))))

# Build "downall" target that takes down all workers that are compatible with our arch
$(foreach b,$(BUILD_BOTNAMES),$(eval $(call add_dep,downall,down-$(b))))


# Dummy rule for if we don't have one
override.env:
	touch $@

# Here's where we take our templates and build docker-compose files out of them
define build_dockercompose
build-$(1): build/$(1)/docker-compose.yml build/$(1)/worker/Dockerfile build/$(1)/tabularasa/Dockerfile

dockerdeps-$(1): $(shell ../dockerdeps ../workerbase/$(call bot_image,$(1)).Dockerfile)

build/$(1)/tabularasa/Dockerfile: Dockerfile.template start_worker.sh dockerdeps-$(1)
	@echo $(1)/tabularasa
	@# Build tabularasa directory
	@mkdir -p "build/$(1)/tabularasa"
	@echo "## This file was autogenerated" > "build/$(1)/tabularasa/Dockerfile"
	@echo "# Do not edit directly; edit the template files" >> "build/$(1)/tabularasa/Dockerfile"
	@echo "FROM $(call tabularasa_tag_name,$(call bot_image,$(1)))" >> "build/$(1)/tabularasa/Dockerfile"
	@cat Dockerfile.template >> "build/$(1)/tabularasa/Dockerfile"
	@cp ./start_worker.sh "build/$(1)/tabularasa/start_worker.sh"

build/$(1)/worker/Dockerfile: Dockerfile.template start_worker.sh dockerdeps-$(1)
	@echo $(1)/worker
	@# Build worker directory
	@mkdir -p "build/$(1)/worker"
	@echo "## This file was autogenerated" > "build/$(1)/worker/Dockerfile"
	@echo "# Do not edit directly; edit the template files" >> "build/$(1)/worker/Dockerfile"
	@echo "FROM $(call worker_tag_name,$(call bot_image,$(1)))" >> "build/$(1)/worker/Dockerfile"
	@cat Dockerfile.template >> "build/$(1)/worker/Dockerfile"
	@cp ./start_worker.sh "build/$(1)/worker/start_worker.sh"

build/$(1)/docker-compose.yml: docker-compose.template.yml override.env secret.env dockerdeps-$(1)
	@echo $(1)
	@mkdir -p "build/$(1)"
	@echo "## Autogenerated from secret.env and override.env" > "build/$(1)/.env"
	@cat secret.env >> "build/$(1)/.env"
	@[ ! -f override.env ] || cat override.env >> "build/$(1)/.env"
	@sed -e "s/{service_name}/$(1)/g" docker-compose.template.yml > "build/$(1)/docker-compose.yml"
	@sed -i.bak -e "s&{home}&$(HOME)&g" "build/$(1)/docker-compose.yml"
	@case $(call worker_tag_name,$(1)) in \
		*x86) sed -i.bak -e "s/{linux32}/linux32/g" "build/$(1)/docker-compose.yml";; \
		*)    sed -i.bak -e "s/{linux32}/       /g" "build/$(1)/docker-compose.yml";; \
	esac
	@rm -f build/$(1)/*.bak


pull-$(1):
	docker pull $(call worker_tag_name,$(1))

deploy-$(1): build-$(1) ipv6_internal ccache_volume srccache_volume
	@# Build our new worker, take down the old one and bring the new one up
	@cd build/$(1); \
	docker-compose build --pull; \
	COMPOSE_HTTP_TIMEOUT=300 docker-compose up -d

down-$(1):
	@if [ -d build/$(1) ]; then \
		cd build/$(1); \
		docker-compose down --remove-orphans; \
	fi
endef

# Makefile target to make our internal ipv6 network
ipv6_internal:
	@if [ -z "$(shell docker network ls | grep ipv6_internal)" ]; then \
		echo "Creating internal ipv6 docker network..."; \
		docker network create --internal --ipv6 --subnet "fdeb:feed:face::/48" ipv6_internal; \
	fi

# Call build_dockercompose on each and every bot
$(foreach b,$(BOTNAMES),$(eval $(call build_dockercompose,$(b))))

# Makefile target to make our ccache volume
define init_volume
$(1)_volume:
	@if [ -z "$$(shell docker volume ls | grep $(1))" ]; then \
		echo -n "Creating $(1) docker volume..."; \
		docker volume create --name=$(1); \
		docker run -ti -v $(1):/$(1) alpine /bin/sh -c "chown 1337:1337 /$(1)"; \
	fi
endef

# Instantiate our volume initialization targets
$(eval $(call init_volume,ccache))
$(eval $(call init_volume,srccache))


clean:
	rm -rf build
