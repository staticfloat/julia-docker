include ../common.mk

# Make our own HFS off of the files in this directory
HFS:=$(subst .harbor,,$(wildcard *.harbor))
BUILD_HFS=$(call BUILD_FILT,$(HFS))

# Build "dockerfiles" target that assembles all Dockerfiles
$(foreach f,$(HFS),$(eval $(call add_dep,dockerfiles,build/$(f)/Dockerfile)))

# Build "buildall" target that attempts to build every Dockerfile in the room,
# but only from the ones that our build architecture can manage.
$(foreach f,$(BUILD_HFS),$(eval $(call add_dep,buildall,build-$(f))))

# Build "pushall" target that pushes up the result of "buildall"
$(foreach f,$(BUILD_HFS),$(eval $(call add_dep,pushall,push-$(f))))

# This is where we put our derived harbor files
lib:
	ln -sf ../workerbase/lib lib
patches:
	ln -sf ../workerbase/patches patches

define build_dockerfile
# Running just `make build-crossbuild-x64` will build that image
build-$(1): build/$(1)/Dockerfile
	docker build --pull -t $(call crossbuild_tag_name,$(1)) "build/$(1)"

buildsquash-$(1): build/$(1)/Dockerfile
	$(DOCKER_BUILD) --pull -t $(call crossbuild_tag_name,$(1)) "build/$(1)"

shell-$(1):
	docker run -ti $(call crossbuild_tag_name,$(1))

# Running `make push-ubuntu16_04-x86` will upload that image to
push-$(1): buildsquash-$(1)
	docker push $(call crossbuild_tag_name,$(1))

# This is how we build the actual Dockerfile
build/$(1)/Dockerfile: $(1).harbor lib patches Makefile
	@if [ ! -f "$(1).harbor" ]; then \
		echo "Target \"$(1)\" is invalid, recheck your spelling good sir."; \
		exit 1; \
	fi
	@mkdir -p "build/$(1)"
	@rm -f "build/$(1)/Dockerfile.tmp"

	@# Build the altered Dockerfile
	@echo "$(1).harbor"
	@harbor "$(1).harbor" -o "build/$(1)/Dockerfile.tmp"
	@echo "## This file was autogenerated" > "build/$(1)/Dockerfile"
	@echo "# Do not edit directly; edit the .harbor files" >> "build/$(1)/Dockerfile"
	@echo "#" >> "build/$(1)/Dockerfile"
	@echo "# To build this docker image via \`make\`, run \`make build-$(1)\` in the \`crossbuild\` directory" >> "build/$(1)/Dockerfile"
	@echo "# To build this docker image manually, run \`docker build --pull -t $(call crossbuild_tag_name,$(1)) .\`" >> "build/$(1)/Dockerfile"
	@echo >> "build/$(1)/Dockerfile"
	@cat "build/$(1)/Dockerfile.tmp" >> "build/$(1)/Dockerfile"
	@rm -f "build/$(1)/Dockerfile.tmp"
	@cp lib/*.sh "build/$(1)/"
	@cp -R cmake_toolchains/ "build/$(1)/"
	@cp -R patches/ "build/$(1)/"
endef

$(foreach f,$(HFS),$(eval $(call build_dockerfile,$(f))))

/tmp/rootfs.tar: build-crossbuild-x64
	@echo "Exporting build image to $@"
	@ IMG_NAME=$(call crossbuild_tag_name,crossbuild-x64); \
	echo "Starting docker container for $$IMG_NAME..."; \
	CONTAINER_ID=$$(docker run -ti --rm -d $$IMG_NAME bash); \
	echo "Running in container $$CONTAINER_ID"; \
	echo "Exporting..."; \
	docker export $$CONTAINER_ID -o $@; \
	echo "Stopping container..."; \
	docker stop $$CONTAINER_ID >/dev/null

# Extract and cleanup the rootfs
/tmp/rootfs: /tmp/rootfs.tar
	@echo "Unpacking..."; \
	rm -rf $@; \
	mkdir -p $@; \
	tar xf $< -C $@; \
	echo "Cleaning up $@..."; \
	rm -f $@/dev/null; \
	touch $@/dev/null; \
	touch $@/dev/ptmx; \
	rm -rf $@/usr/share/terminfo; \
	echo "Removing OSX SDK..."; \
	rm -rf $@/opt/x86_64-apple-darwin14/MacOSX*.sdk

# Package 'em all up
SQUASHFS_OPTS=-force-uid 1000 -force-gid 1000 -comp xz -b 1048576 -Xdict-size 100%
shards: /tmp/rootfs
	@ echo "Repackaging..."; \
	for f in $</opt/*-*-*; do \
		f_target=$$(basename $${f}); \
		f_out=/tmp/rootfs-$${f_target}; \
		rm -f $${f_out}.tar.gz $${f_out}.squashfs; \
		echo "  Packaging tar.gz $${f_target} shard from $${f}..."; \
		GZIP=-9 tar zcf $${f_out}.tar.gz -C $${f}  .; \
		echo "  Packaging squashfs $${f_target} shard from $${f}..."; \
		mksquashfs $${f} $${f_out}.squashfs $(SQUASHFS_OPTS); \
		echo "  Checksumming..."; \
		shasum -a 256 $${f_out}.tar.gz | cut -d' ' -f1 > $${f_out}.tar.gz.sha256; \
		shasum -a 256 $${f_out}.squashfs | cut -d' ' -f1 > $${f_out}.squashfs.sha256; \
		echo "  Removing $${f_target} from unpacked directory..."; \
		rm -rf $${f}; \
	done; \
	echo "Packaging tar.gz rootfs base..."; \
	GZIP=-9 tar zcf /tmp/rootfs.tar.gz -C $< .; \
	echo "Packaging squashfs rootfs base..."; \
	mksquashfs $< /tmp/rootfs.squashfs $(SQUASHFS_OPTS); \
	echo "Checksumming..."; \
	shasum -a 256 /tmp/rootfs.tar.gz | cut -d' ' -f1 > /tmp/rootfs.tar.gz.sha256; \
	shasum -a 256 /tmp/rootfs.squashfs | cut -d' ' -f1 > /tmp/rootfs.squashfs.sha256; \
	echo "Final cleanup..."; \
	rm -rf /tmp/rootfs

push-rootfs: shards
	@echo "Uploading to S3..."
	@ DATE_STR=$$(date +%Y-%m-%d); \
	for f in /tmp/rootfs*.tar.gz; do \
		f_tarball=$${f}; \
		f_squashfs=$${f%.*.*}.squashfs; \
		f_prefix=$$(basename $${f%.*.*}); \
		s3_prefix="s3://julialangmirror/binarybuilder"; \
		url_prefix="https://julialangmirror.s3.amazonaws.com/binarybuilder"; \
		aws s3 cp --acl public-read $${f_tarball} $${s3_prefix}-$${f_prefix}-$${DATE_STR}.tar.gz; \
		aws s3 cp --acl public-read $${f_squashfs} $${s3_prefix}-$${f_prefix}-$${DATE_STR}.squashfs; \
		aws s3 cp --acl public-read $${f_tarball}.sha256 $${s3_prefix}-$${f_prefix}-$${DATE_STR}.tar.gz.sha256; \
		aws s3 cp --acl public-read $${f_squashfs}.sha256 $${s3_prefix}-$${f_prefix}-$${DATE_STR}.squashfs.sha256; \
	done

print-hashes:
	@# Print out the squashfs hashes first
	@echo "    squashfs_hashes = Dict("
	@echo "        \"base\" => \"$$(cat /tmp/rootfs.squashfs.sha256)\""
	@for f in /tmp/rootfs-*.squashfs; do \
		f_prefix=$$(basename $${f%.*}); \
		triplet=$${f_prefix:7}; \
		echo "        \"$${triplet}\" => \"$$(cat $${f}.sha256)\","; \
	done
	@echo "    )"
	@# Then print out the tarball hashes:
	@echo "    tarball_hashes = Dict("
	@echo "        \"base\" => \"$$(cat /tmp/rootfs.tar.gz.sha256)\""
	@for f in /tmp/rootfs-*.tar.gz; do \
		f_prefix=$$(basename $${f%.*.*}); \
		triplet=$${f_prefix:7}; \
		echo "        \"$${triplet}\" => \"$$(cat $${f}.sha256)\","; \
	done
	@echo "    )"


clean:
	rm -rf build lib patches
