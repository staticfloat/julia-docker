include ../common.mk

# Make our own HFS off of the files in this directory
HFS:=$(subst .harbor,,$(wildcard *.harbor))
BUILD_HFS=$(call BUILD_FILT,$(HFS))

# Build "dockerfiles" target that assembles all Dockerfiles
$(foreach f,$(HFS),$(eval $(call add_dep,dockerfiles,build/$(f)/Dockerfile)))

# Build "buildall" target that attempts to build every Dockerfile in the room,
# but only from the ones that our build architecture can manage.
$(foreach f,$(BUILD_HFS),$(eval $(call add_dep,buildall,build-$(f))))

# Build "pushall" target that pushes up the result of "buildall"
$(foreach f,$(BUILD_HFS),$(eval $(call add_dep,pushall,push-$(f))))

# This is where we put our derived harbor files
lib:
	ln -sf ../workerbase/lib lib
patches:
	ln -sf ../workerbase/patches patches

define build_dockerfile
# Running just `make build-crossbuild-x64` will build that image
build-$(1): build/$(1)/Dockerfile
	$(DOCKER_BUILD) --pull -t $(call crossbuild_tag_name,$(1)) "build/$(1)"

shell-$(1):
	docker run -ti $(call crossbuild_tag_name,$(1))

# Running `make push-ubuntu16_04-x86` will upload that image to
push-$(1):
	docker push $(call crossbuild_tag_name,$(1))

# This is how we build the actual Dockerfile
build/$(1)/Dockerfile: $(1).harbor lib patches Makefile
	@if [ ! -f "$(1).harbor" ]; then \
		echo "Target \"$(1)\" is invalid, recheck your spelling good sir."; \
		exit 1; \
	fi
	@mkdir -p "build/$(1)"
	@rm -f "build/$(1)/Dockerfile.tmp"

	@# Build the altered Dockerfile
	@echo "$(1).harbor"
	@harbor "$(1).harbor" -o "build/$(1)/Dockerfile.tmp"
	@echo "## This file was autogenerated" > "build/$(1)/Dockerfile"
	@echo "# Do not edit directly; edit the .harbor files" >> "build/$(1)/Dockerfile"
	@echo "#" >> "build/$(1)/Dockerfile"
	@echo "# To build this docker image via \`make\`, run \`make build-$(1)\` in the \`crossbuild\` directory" >> "build/$(1)/Dockerfile"
	@echo "# To build this docker image manually, run \`docker build --pull -t $(call crossbuild_tag_name,$(1)) .\`" >> "build/$(1)/Dockerfile"
	@echo >> "build/$(1)/Dockerfile"
	@cat "build/$(1)/Dockerfile.tmp" >> "build/$(1)/Dockerfile"
	@rm -f "build/$(1)/Dockerfile.tmp"
	@cp lib/*.sh "build/$(1)/"
	@cp -R patches/ "build/$(1)/"
endef

$(foreach f,$(HFS),$(eval $(call build_dockerfile,$(f))))

rootfs.tar.gz: build-crossbuild-alpine-x64
	echo "Exporting build image to $@"
	@ IMG_NAME=$(call crossbuild_tag_name,crossbuild-alpine-x64); \
	echo "Starting docker container for $$IMG_NAME..."; \
	CONTAINER_ID=$$(docker run -ti --rm -d $$IMG_NAME bash); \
	echo "Running in container $$CONTAINER_ID, exporting..."; \
	docker export $$CONTAINER_ID | gzip -9 > $@; \
	echo "Stopping container..."; \
	docker stop $$CONTAINER_ID

rootfs.tar.gz.sha512: rootfs.tar.gz
	shasum -a 512 $< | cut -d' ' -f1 > $@

push-rootfs: rootfs.tar.gz rootfs.tar.gz.sha512
	DATE_STR=$$(date +%Y-%m-%d); \
	aws s3 cp --acl public-read ./rootfs.tar.gz s3://julialangmirror/binarybuilder-rootfs-$${DATE_STR}.tar.gz; \
	aws s3 cp --acl public-read ./rootfs.tar.gz.sha512 s3://julialangmirror/binarybuilder-rootfs-$${DATE_STR}.tar.gz.sha512



clean:
	rm -rf build lib patches
