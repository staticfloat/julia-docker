include ../common.mk

# Make our own HFS off of the files in this directory
HFS:=$(subst .harbor,,$(wildcard *.harbor))
BUILD_HFS=$(call BUILD_FILT,$(HFS))

# Build "dockerfiles" target that assembles all Dockerfiles
$(foreach f,$(HFS),$(eval $(call add_dep,dockerfiles,build/$(f)/Dockerfile)))

# Build "buildall" target that attempts to build every Dockerfile in the room,
# but only from the ones that our build architecture can manage.
$(foreach f,$(BUILD_HFS),$(eval $(call add_dep,buildall,build-$(f))))

# Build "pushall" target that pushes up the result of "buildall"
$(foreach f,$(BUILD_HFS),$(eval $(call add_dep,pushall,push-$(f))))

# This is where we put our derived harbor files
lib:
	ln -sf ../workerbase/lib lib
patches:
	ln -sf ../workerbase/patches patches

define build_dockerfile
# Running just `make build-crossbuild-x64` will build that image
build-$(1): build/$(1)/Dockerfile
	$(DOCKER_BUILD) --pull -t $(call crossbuild_tag_name,$(1)) "build/$(1)"

shell-$(1):
	docker run -ti $(call crossbuild_tag_name,$(1))

# Running `make push-ubuntu16_04-x86` will upload that image to
push-$(1):
	docker push $(call crossbuild_tag_name,$(1))

# This is how we build the actual Dockerfile
build/$(1)/Dockerfile: $(1).harbor lib patches Makefile
	@if [ ! -f "$(1).harbor" ]; then \
		echo "Target \"$(1)\" is invalid, recheck your spelling good sir."; \
		exit 1; \
	fi
	@mkdir -p "build/$(1)"
	@rm -f "build/$(1)/Dockerfile.tmp"

	@# Build the altered Dockerfile
	@echo "$(1).harbor"
	@harbor "$(1).harbor" -o "build/$(1)/Dockerfile.tmp"
	@echo "## This file was autogenerated" > "build/$(1)/Dockerfile"
	@echo "# Do not edit directly; edit the .harbor files" >> "build/$(1)/Dockerfile"
	@echo "#" >> "build/$(1)/Dockerfile"
	@echo "# To build this docker image via \`make\`, run \`make build-$(1)\` in the \`crossbuild\` directory" >> "build/$(1)/Dockerfile"
	@echo "# To build this docker image manually, run \`docker build --pull -t $(call crossbuild_tag_name,$(1)) .\`" >> "build/$(1)/Dockerfile"
	@echo >> "build/$(1)/Dockerfile"
	@cat "build/$(1)/Dockerfile.tmp" >> "build/$(1)/Dockerfile"
	@rm -f "build/$(1)/Dockerfile.tmp"
	@cp lib/*.sh "build/$(1)/"
	@cp -R cmake_toolchains/ "build/$(1)/"
	@cp -R patches/ "build/$(1)/"
endef

$(foreach f,$(HFS),$(eval $(call build_dockerfile,$(f))))

/tmp/rootfs.tar: build-crossbuild-x64
	@echo "Exporting build image to $@"
	@ IMG_NAME=$(call crossbuild_tag_name,crossbuild-x64); \
	echo "Starting docker container for $$IMG_NAME..."; \
	CONTAINER_ID=$$(docker run -ti --rm -d $$IMG_NAME bash); \
	echo "Running in container $$CONTAINER_ID"; \
	echo "Exporting..."; \
	docker export $$CONTAINER_ID -o $@; \
	echo "Stopping container..."; \
	docker stop $$CONTAINER_ID

# We need to remove special files that we can't extract properly on
# host platforms here
/tmp/rootfs.tar.gz /tmp/rootfs.squash: /tmp/rootfs.tar
	@echo "Unpacking..."; \
	rm -rf /tmp/rootfs; \
	mkdir -p /tmp/rootfs; \
	tar xf $< -C /tmp/rootfs; \
   	echo "Beginning cleanup operations..."; \
	rm -f /tmp/rootfs/dev/null; \
	touch /tmp/rootfs/dev/null; \
	touch /tmp/rootfs/dev/ptmx; \
	rm -rf /tmp/rootfs/usr/share/terminfo; \
	echo "Repackaging..."; \
	GZIP=-9 tar zcf $@ -C /tmp/rootfs .; \
	mksquashfs /tmp/rootfs /tmp/rootfs.squash -force-uid 1000 -force-gid 1000 -noappend; \
	echo "Final cleanup..."; \
	rm -rf /tmp/rootfs

/tmp/rootfs.tar.gz.sha256: /tmp/rootfs.tar.gz
	@shasum -a 256 $< | cut -d' ' -f1 > $@

/tmp/rootfs.squash.sha256: /tmp/rootfs.squash
	@shasum -a 256 $< | cut -d' ' -f1 > $@

push-rootfs: /tmp/rootfs.tar.gz /tmp/rootfs.tar.gz.sha256 /tmp/rootfs.squash /tmp/rootfs.squash.sha256
	@echo "Uploading to S3..."
	@ DATE_STR=$$(date +%Y-%m-%d); \
	aws s3 cp --acl public-read /tmp/rootfs.tar.gz s3://julialangmirror/binarybuilder-rootfs-$${DATE_STR}.tar.gz; \
	aws s3 cp --acl public-read /tmp/rootfs.tar.gz.sha256 s3://julialangmirror/binarybuilder-rootfs-$${DATE_STR}.tar.gz.sha256; \
	aws s3 cp --acl public-read /tmp/rootfs.squash s3://julialangmirror/binarybuilder-rootfs-$${DATE_STR}.squash; \
	aws s3 cp --acl public-read /tmp/rootfs.squash.sha256 s3://julialangmirror/binarybuilder-rootfs-$${DATE_STR}.squash.sha256; \
	echo "URL (.tar.gz): https://julialangmirror.s3.amazonaws.com/binarybuilder-rootfs-$${DATE_STR}.tar.gz"; \
	echo "hash: $$(cat /tmp/rootfs.tar.gz.sha256)" \
	echo "URL (.tar.gz): https://julialangmirror.s3.amazonaws.com/binarybuilder-rootfs-$${DATE_STR}.squash"; \
	echo "hash: $$(cat /tmp/rootfs.squash.sha256)"



clean:
	rm -rf build lib patches
